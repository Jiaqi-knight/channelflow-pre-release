Channelflow installation            2013-06-21 

NOTE: more documentation can be found at

  http://www.channelflow.org/dokuwiki/doku.php/docs



=========================================================================
DIRECTORY STRUCTURE

Channelflow follows standard GNU packaging structure as much as possible.
The main subdirectories are

channelflow/     the channelflow library source code
programs/        executable programs
examples/        how to write and compile your own channelflow program
tests/           a suite of test programs for the library code
data/            a few data files useful for the test programs
doc/             tutorial, timing results
doc/userguide/   in-depth LaTeX documentation
doc/mpi          a bit information on the parallelization

=========================================================================
BASIC INSTALLATION: cmake; make; make install

If you're moderately lucky you can compile, verify, install, and start
using channelflow with a few commands. Most likely you will want to
install channelflow into your home directory. Here we will use 
$HOME/usr as install path, so the binaries will end up in $HOME/usr/bin
and the libraries in $HOME/usr/lib

  tar xvjf channeflow-1.9.0.tar.bz2
  cd channelflow-1.9.0
  mkdir build
  cd build
  cmake .. -DCMAKE_INSTALL_PREFIX=$HOME/usr
  make
  make test       # optional
  make install

When this finishes, the channelflow executables, header files, and
libraries will be installed in ~/usr/bin, ~/usr/include, and ~/usr/lib,
respectively (where ~ stands for your home directory)

By default, only the static channelflow library is built. This increases the
size of the binaries, but avoids the need to set the LD_LIBRARY_PATH.

Now you should be able to run the channelflow utility programs in ~/usr/bin.
See the VERY BASIC USAGE section below for more on that. You'll probably
want to put ~/usr/bin in your path, if it's not already there. Please refer
to your shell documentation on that.

=========================================================================
IMPORTANT VARIATIONS ON BASIC INSTALLATION

Before getting into greater detail, here are few important variations
to the installation procedure.

1. You can skip the make install part. Your programs are then found in
build/programs and the library in build/channelflow

2. Or you can install into the default installation directory /usr/local
by dropping the -DCMAKE_INSTALL_PREFIX= option to cmake, e.g. run 'cmake'.
If you do this you'll need to run "make install" as root.

3. If anything goes wrong, check the output of the above cmake command for 
errors. If you change something, run 'make clean' first and remember to
delete CMakeCache.txt.

4. You can aid cmake in finding external libraries with the options 
-DWITH_FFTW=(path) and -DWITH_HDF5=(path) if you have them installed in a non
system directory.

5. You can disable the static library and static linking with 
-DENABLE_STATIC=off -DENABLE_SHARED=on
Building and linking static is default. If building of shared libraries is
enabled, the programs will be linked to that one instead.

6. You can disable the use of MPI with -DUSE_MPI=off

7. You can build with debugging flags (programs run slower but enables
many useful checks during runtime) with -DCMAKE_BUILD_TYPE=debug

8. If you encounter error messages like:
"runtime library ... may be hidden by files in ...", this is due to the fact
that cmake tries to save the library paths in the binary, which eases execution
but may cause problems if you have the same library in different directories.
In this case, you can disable setting of this rpath with -DSET_RPATH=off and 
explicitely set the LD_LIBRARY_PATH to point to the libraries you want.


=========================================================================
VERY BASIC USAGE: couette -h

To check that the executables installed correctly, try running "couette.x -h"
or "couette --help". For example,

  gibson@tansen$ ~/bin/couette --help
  couette :
        integrate plane Couette or channel flow from a given initial condition
        and save velocity fields to disk.

  options :
    -T0       --T0                <real>      default == 0           start time
    -T1       --T1                <real>      default == 100         end time
    -dt       --dt                <real>      default == 0.03125     timestep
    -vdt      --variabledt                                           adjust dt to keep CFL in bounds
    etc.

Each channelflow executable program in ~/bin will print out a short description
of the program's purpose and command line options, if you run it with a -h or
--help option. For an overview of the most important programs and how to use
them, please see channelflow-1.x.x/doc/TUTORIAL (to be written).


=========================================================================
2. Verifying correct behavior of installation

The tests/ directory contains a number of test programs that verify that
channelflow behaves corretly. The tests fall into two groups: simple tests
of channelflow classes and their member functions, and tests of full-fledged
Navier-Stokes simulations.

To run the tests, run

  make test

The output will look like

  tridagTest:        pass
  helmholtzTest:     pass
  tausolverTest:     pass
  poissonTest:       pass
  pressureTest:      pass

If a test runs to completion but fails, you'll see "FAIL" instead of "pass".
If a test seg faults or produces a run-time error, you'll get neither. In
general, the tests produce a numerical approximation g to a known function f,
and the passes if L2Norm(f-g)/L2Norm(f) < max_error, were max_error is set to
a predetermined value for the given test-problem parameters.

=========================================================================
3. Compiling your own channelflow programs

The channelflow/examples directory has several examples of simple
programs and a simple CMakeLists.txt file.


=========================================================================
4. Debugging and profiling channelflow programs

-------------------------------------------------------------------------
4a. Compiling debugging and profiling libraries.

To compile debugging and profiling libraries, run cmake with the options

-DCMAKE_BUILD_TYPE=debug

or 

-DCMAKE_BUILD_TYPE=profile

-------------------------------------------------------------------------
4b. Debugging channelflow programs

The Channelflow debugging libraries have quite a few run-time checks for
things like out-of-bounds errors on indices and discretization compatibility
between binary operations on fields. You can catch such errors by running your
channelflow programs with debugging turned on; the debugging libraries will
produce a relatively informative run-time error message, which can then
be checked in-depth with a debugger.

If you skip this check and run your channelflow programs with optimized
libraries, the error will produce a seg fault, or worse, keep running without
complaint! Thus it is always a good idea to test your channelflow programs
with the debugging libs before running them for real.

To compile a debugging executable, run "make <program>". E.g.

  akbar$ make errorexamples
  g++ -Wall -g -O1  -I/usr/local/include  -o errorexamples.do -c errorexamples.cpp
  g++ -g -o errorexamples.dx errorexamples.do  -L/usr/local/lib -lchflowdebug -lfftw3 -lm
  rm errorexamples.do

  akbar$ ./examples/errorexamples
  (deliberately causing an index-out-of-bounds error...)
  errorexamples: /usr/local/include/channelflow/flowfield.h:347:
    int FlowField::flatten(int, int, int, int) const:
    Assertion `ny>=0 && ny<Ny_' failed.
  Aborted

Compare this to the same code linked against optimized libraries:

  akbar$ make ./errorexamples
  g++ -Wall -O2 -DNDEBUG -I/usr/local/include  -c errorexamples.cpp
  g++ -o errorexamples.x errorexamples.o  -L/usr/local/lib -lchflow -lfftw3 -lm
  rm errorexamples.o

  akbar$ ./examples/errorexamples
  (deliberately causing an index-out-of-bounds error...)
  (deliberately causing a field-state error...)
  (deliberately causing a field incompatibility error...)
  Segmentation fault

The optimized error examples program runs straight through two serious
programming errors without warning, before hitting one that's bad enough to
cause a segmentation fault and stop execution! A channelflow program that
contains such errors might well produce numerical garbage with no warning
whatsoever. The lesson is: Test your codes for a few time steps with debugging
turned on before running them for production use.

When you encounter a run-time error in a debugging executable, it's almost
always necessary to rerun the program within a debugger to examine the stack
and the values of variables. You can try "gdb errorexamples.dx", or better,
use a GUI debugger. I run "M-x gdb errorexamples.dx" within xemacs.
